#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>
#include <math.h>

Adafruit_PWMServoDriver pca9685 = Adafruit_PWMServoDriver(0x40);

//conexões servos
#define quadril_1  0   //quadril servo 5
#define pata_1  1  //pata servo 1
#define coxa_1 2 //coxa servo 11
#define quadril_2  3   //quadril servo 2
#define pata_2  4  //pata servo 3
#define coxa_2 5 //coxa servo 4
#define quadril_3  6   //quadril servo 6
#define pata_3  7  //pata servo 7
#define coxa_3 8 //coxa servo 8
#define quadril_4  9   //quadril servo 9
#define pata_4  10  //pata servo 10
#define coxa_4 11 //coxa servo 12

#define KNOB1 34 // entrada analógica 1
#define KNOB2 35 // entrada analógica 2
#define KNOB3 32 // entrada analógica 3

// Constantes cinemática inversa
const float l1 = 34;
const float l2 = 55;
const float l3 = 55;
float theta_1, theta_2, theta_3;
// Coordenadas
double h, c, betha, arg_theta1, arg_theta2, arg_theta3, arg_betha,x2,y2,z2,rotx;
//inicilizando valores do PWM, com seus respectivos coeficientes m e c
// servos: 5,1,11,2,3,4,6,7,8,9,10,12
float PWMs[12][3] = {{0,2.25,85.84},{0,2.23,73.08},{0,2.25,61.29},{0,2.24,130.21},{0,2.25,92.84},{0,2.21,60.57},{0,2.27,63.92},{0,2.22,59.97},{0,2.22,65.72},{0,2.16,65.35},{0,2.32,67.42},{0,2.22,84.11}};

void setup(){
  Serial.begin(115200);
  // Knob input
  pinMode(KNOB1,INPUT);
  pinMode(KNOB2,INPUT);
  pinMode(KNOB3,INPUT);
  // Inicializando PCA9685
  pca9685.begin();
  // Frequência de PWM 50Hz
  pca9685.setPWMFreq(50);
  // posições iniciais para todos
  for (int i = 0; i <= 11; i++){
    servoWrite(i,90,false);
  }
  delay(5000);
}

void loop() {
  //Angles debug
  //angles_debug(quadril_1,pata_1,coxa_1);
  //Coordinates debug
  //pendant(20,quadril_1,pata_1,coxa_1,true); // controle as coordenadas do efetor final e realize leitura, 20 para controle real time, 150 pafra leitura de valores
  /*
  float x_spread = map(analogRead(KNOB1),0,4095,-48 +44.84,-74 +44.84);
  float y_up = map(analogRead(KNOB2),0,4095,32,73);
  float y_down = map(analogRead(KNOB3),0,4095,32,73);
  Serial.print("x_spread: ");
  Serial.print(x_spread);
  Serial.print(" y_up: ");
  Serial.print(y_up);
  Serial.print(" y_down: ");
  Serial.println(y_down);
  
  float po[2] = {-44.84,y_down};
  float p1[2] = {-46.86,y_up};
  float p2[2] = {-64.67,y_up};
  float p3[2] = {-44.84+x_spread,y_down};

  bezierCurve(0.05,po,p1,p2,p3); */
  //elipseDraw(2,32,-55.5,49);
  //delay(20);
  //servoCalibrar(calibrar);
  /*
  int angle1 = map(analogRead(KNOB1),0,4095,0,180);
  servoWrite(calibrar,angle1,true);
  */
}
void pendant(int dly,int quadril, int pata, int coxa, bool print){
    //delay recomendado de 150
    int x = map(analogRead(KNOB1),0,4095,-77,40);
    int y = map(analogRead(KNOB2),0,4095,-16,88);
    int z = map(analogRead(KNOB3),0,4095,26,92);
    //coordenadas2D(x,z,true);
    coordenadas3D(x,y,z,quadril_1, pata_1, coxa_1,print);
    delay(dly);
}
void angle_debug(int quadril, int pata, int coxa){

  int angle1 = map(analogRead(KNOB1),0,4095,0,180);
  int angle2 = map(analogRead(KNOB2),0,4095,0,180);
  int angle3 = map(analogRead(KNOB3),0,4095,0,180);
  servoWrite(pata,angle1,true);
  servoWrite(coxa,angle2,true);
  servoWrite(quadril,angle3,true);
  delay(20);

}
void servoCalibrar(int servo){

  int leitura = map(analogRead(KNOB1),0,4095,60,700);
  PWMs[servo][0] = roundf(leitura);
  pca9685.setPWM(servo, 0, (int)PWMs[servo][0]);
  // Print to serial monitor
  Serial.print("Servo ");
  Serial.print(servo);
  Serial.print(", PWM: ");
  Serial.println(leitura);
  delay(20);

}

void servoWrite(int servo, int angle_deg, bool print){

  PWMs[servo][0] = roundf(PWMs[servo][1]*angle_deg + PWMs[servo][2]);
  pca9685.setPWM(servo, 0, (int)PWMs[servo][0]);
  // Print to serial monitor
  if (print){
    if(servo == coxa_1 || servo == coxa_2 || servo == coxa_3|| servo == coxa_4){
      Serial.print("Coxa ");
    }else if (servo == quadril_1 || servo == quadril_2 || servo == quadril_3 || servo == quadril_4){
      Serial.print("Quadril ");
    }else{
      Serial.print("Pata ");
    }
      Serial.print("angulo: ");
      Serial.println(angle_deg);
  }
  delay(20);

}
void coordenadas3D(double x, double y, double z, int quadril, int pata, int coxa, bool print){
  c = sqrt(z*z+y*y);
  theta_1 = PI - atan2(z,y)-asin(l1/c);
  if(0 <= theta_1 && theta_1 <=2*PI){
    //aplicando transformação de coordenadas
    rotx = - PI/2 + theta_1;
    z2 = y*sin(rotx)+z*cos(rotx);
    h = sqrt(z2*z2+x*x);
    //checando por inconsistências
    arg_theta2 = (h*h+l2*l2-l3*l3)/(2*l2*h);
    // betha angle
    betha = (-h*h+l2*l2+l3*l3)/(2*l2*l3);
      if ((arg_theta2 >=-1 && arg_theta2 <=1) && (betha >= -1 && betha <= 1)){
      theta_2 = acos(arg_theta2)-atan2(x,z);
      theta_3 = -theta_2+ 3*PI/2 - acos(betha);
      servoWrite(pata,180/PI*theta_3,print);
      servoWrite(coxa,theta_2*180/PI,print);
      servoWrite(quadril,theta_1*180/PI,print);
      if (print){
        // Imprimindo valores na interface serial
        Serial.print("[");
        Serial.print(x);
        Serial.print(",");
        Serial.print(y);
        Serial.print(",");
        Serial.print(z);
        Serial.println("]");
      }
    }
  }
}
void bezierCurve(float step, float po[2],float p1[2],float p2[2], float p3[2], int quadril, int pata, int coxa, double z){
  float px,py,u;
  for (u = 0;u<=1; u = u+step){
    px = pow((1-u),3)*po[0]+3*u*pow((1-u),2)*p1[0]+3*pow(u,2)*(1-u)*p2[0]+pow(u,3)*p3[0];
    py = pow((1-u),3)*po[1]+3*u*pow((1-u),2)*p1[1]+3*pow(u,2)*(1-u)*p2[1]+pow(u,3)*p3[1];
    coordenadas3D(px,py,z,quadril, pata, coxa,false);
  }
}
